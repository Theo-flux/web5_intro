var n=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var p=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;var u={}.toString;function o(t=32){if(n&&typeof n.getRandomValues=="function")return n.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}function l(t){if(!t||t.property===void 0||t.inObject===void 0)throw new TypeError("One or more required parameters missing: 'property, properties'");let{property:e,inObject:r}=t;if(!(e in r))throw new TypeError(`Required parameter missing: '${e}'`)}function y(t){if(!t||t.property===void 0||t.allowedProperties===void 0)throw new TypeError("One or more required parameters missing: 'property, allowedProperties'");let{property:e,allowedProperties:r}=t;if(Array.isArray(r)&&!r.includes(e)||r instanceof Set&&!r.has(e)||r instanceof Map&&!r.has(e)){let i=Array.from(r instanceof Map?r.keys():r).join(", ");throw new TypeError(`Out of range: '${e}'. Must be one of '${i}'`)}}function g(t){let e={Ed25519:"EdDSA","P-256":"ES256","P-384":"ES384","P-521":"ES512",secp256k1:"ES256K"};if(t.alg&&Object.values(e).includes(t.alg))return t.alg;if(t.crv&&Object.keys(e).includes(t.crv))return e[t.crv];throw new Error(`Unable to determine algorithm based on provided input: alg=${t.alg}, crv=${t.crv}. Supported 'alg' values: ${Object.values(e).join(", ")}. Supported 'crv' values: ${Object.keys(e).join(", ")}.`)}function w(){return!!(globalThis.crypto&&globalThis.crypto.subtle)}function x(t){return o(t)}function b(){return n.randomUUID()}export{l as checkRequiredProperty,y as checkValidProperty,g as getJoseSignatureAlgorithmFromPublicKey,w as isWebCryptoSupported,x as randomBytes,b as randomUuid};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=utils.js.map
